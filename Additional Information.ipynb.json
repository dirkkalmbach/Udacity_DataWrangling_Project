{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# <a id='Top'></a> Wrangling Open Street Map Data  - Additional Information"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Table of Content\n",
    "- [1 Introduction](#Intro)\n",
    "- [2 Getting the Data](#GettingData)\n",
    "    - [2.1 Loading the Data from Open Street Map](#LoadingData)\n",
    "    - [2.2 Some Basic Descriptive Statistics](#BasicStatistics)\n",
    "- [3 Wrangling the Data](#WranglingData)\n",
    "    - [3.1 Auditing the Data](#AuditingData)\n",
    "    - [3.2 Cleaning the Data](#CleaningData)\n",
    "        - [3.2.1 Replace German Umlaute](#ReplaceUmlaute)\n",
    "        - [3.2.2 Replace Abbreviations of Street](#ReplaceAbbrStr)\n",
    "        - [3.2.3 Final Cleaning and Building of JSON-File](#FinalClean)\n",
    "- [4 Importing the Data into MongoDB](#ImportingData)\n",
    "- [5 Analyzing the Data with Pymongo](#Analyzing)\n",
    "    - [5.1 Overview of the Data](#Overview)\n",
    "    - [5.2 Other Ideas about the Data](#Ideas)\n",
    "        - [5.2.1 Create Map of Distances](#Map)\n",
    "        - [5.2.2 Calculate Distances](#Distance)\n",
    "- [References](#References)\n",
    "- [A Appendix](#Appendix)\n",
    "    - [A.1 Import Modules](#ImportModules)\n",
    "    - [A.2 Creating Sample Data File](#CreatingSampleData)\n",
    "    - [A.3 Check for Umlaute](#CheckUmlaute)\n",
    "    - [A.4 Printouts of Data Files](#Printouts)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Intro'></a> \n",
    "## 1 Introduction"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This Notebook is part of the final project of the Udacity course **Data Wrangling with MongoDB**.\n",
    "It acts as an additional document where I provide most of the code I used to answer the short questions of the corresponding doument **Wrangling OpenStreetMap Data with MongoDB**.\n",
    "\n",
    "*Note: To make this document more readable, I provided some larger code snippets in the Appendix. So if you intend to reproduce the code, keep in mind to run the code in the appendix A.1 and A.2 first.*\n",
    "\n",
    "<img style=\"float: left\" src=\"http://dl.dropboxusercontent.com/s/cm5ta8q4kmjkcbh/DirkKalmbach.png?dl=0\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='GettingData'></a> \n",
    "## 2 Getting the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='LoadingData'></a>\n",
    "### 2.1 Loading the Data from Open Street Map"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Downloading the map-file from [OpenStreetMap](http://www.openstreetmap.org/#map=14/50.7296/7.1118) was easy: I manually selected the city boundary of Bonn (1) and downloaded the xml-file via the _Overpass API_ (2):\n",
    "<img src=\"ScreenshotOfMapDownload.png\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I downloaded the osm-file to a folder on my computer and named it `rawfile`:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "I also created a smaller sample file of the `rawfile`. I used the code provided by the Instructor of the course.[[2]](#References) You'll find the code in the [appendix](#CreatingSampleData). I named this file `samplefile`. The following table gives you an overview of the different dataset I used throughout the data wrangling process:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Step | File | File Format | Name in Python | Type in Python| Description\n",
    "--- | --- | --- | --- | ---\n",
    "1a | bonn_osm.xml | xml |`rawfile`| str | OSM-Data of the city boundary of Bonn, Germany downloaded from OpenStreetMap\n",
    "1b | sample.osm| xml | `samplefile`|str| Sample of `rawfile` (about 5%) produced in [A.2](#CreatingSampleData)\n",
    "2 | wrangled_OSM.xml | xml | `outputfile`| str | Dataset produced during the cleaning-process\n",
    "3 | wrangled_OSM.json | json | `data`| list | Cleaned Dataset in json-format ready for import into MongoDB (the file-path is stored in `path_to_data`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "However, if you want to reproduce the code it might be helpful to change the file-paths to your personal need, e.g.: change the path of `rawfile` to your local download folder. You can do this by changing the following variables:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "rawfile = \"/Users/dirkkalmbach/Programming/Nanodegree/ud032/ud032_finalProject/data/bonn_osm.xml\"\n",
    "outputfile = \"/Users/dirkkalmbach/Programming/Nanodegree/ud032/ud032_finalProject/data/wrangled_OSM.xml\"\n",
    "path_to_data = \"/Users/dirkkalmbach/Programming/Nanodegree/ud032/ud032_finalProject/data/wrangled_OSM.json\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_Keep in mind that `samplefile` will be produced automatically and stored in your iPython Home Directory._"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='BasicStatistics'></a>\n",
    "### 2.3 Some Basic Descriptive Statistics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Filesizes:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Size of Raw File: 173 MB\n",
      "Size of Sample File: 8 MB\n"
     ]
    }
   ],
   "source": [
    "def getSize(file):\n",
    "    st = os.stat(file)\n",
    "    return st.st_size/1024**2\n",
    "\n",
    "print(\"Size of Raw File: %d MB\" % (getSize(rawfile)) )\n",
    "print(\"Size of Sample File: %d MB\" % (getSize(samplefile)) )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Count lines:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2715967 number of lines in rafile\n",
      "134575 number of lines in samplefile\n"
     ]
    }
   ],
   "source": [
    "def getNumberOfLines(file):\n",
    "    with open(file) as f:\n",
    "        num_lines = sum(1 for line in f)\n",
    "    return num_lines\n",
    "\n",
    "print(\"%d number of lines in rafile\" % (getNumberOfLines(rawfile)) )\n",
    "print(\"%d number of lines in samplefile\" % (getNumberOfLines(samplefile)) )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Types of tags:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*The following code is from Lesson **6-3 Iterative Parsing** gives an overview of all the tag-types in the xml-dataset:*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'bounds': 1,\n",
      " 'member': 101575,\n",
      " 'meta': 1,\n",
      " 'nd': 986638,\n",
      " 'node': 717260,\n",
      " 'note': 1,\n",
      " 'osm': 1,\n",
      " 'relation': 2389,\n",
      " 'tag': 601939,\n",
      " 'way': 137789}\n",
      "\n",
      "--- Execution time: 3.322 min ---\n"
     ]
    }
   ],
   "source": [
    "############################################################\n",
    "# Comment/Uncomment the following two lines to choose \n",
    "# whether you wants to run the code with Raw or Sample File:\n",
    "file = rawfile\n",
    "#file = samplefile\n",
    "############################################################\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "\n",
    "def count_tags(filename):\n",
    "    tag_types = {}\n",
    "    for event, elem in ET.iterparse(filename):\n",
    "        \n",
    "        if elem.tag in tag_types.keys():\n",
    "            tag_types[elem.tag]+= 1\n",
    "        else:\n",
    "            tag_types[elem.tag]  = 1\n",
    "    return tag_types\n",
    "\n",
    "tags = count_tags(file)\n",
    "pprint.pprint(tags)\n",
    "\n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='WranglingData'></a> \n",
    "## 3 Wrangling the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='AuditingData'></a>  \n",
    "### 3.1 Auditing the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "In this section, I am looking for possible errors in the dataset to get an idea about what needs to be cleaned."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "RESULT FOR auditStrasse: \n",
      "\n",
      "Number of words containing 'Strasse' instead of 'Straße': 3\n",
      "__________________________________________________ \n",
      "\n",
      "RESULT FOR auditK: (i.e.: list of all k-tags) \n",
      "\n",
      "Number of k-tags: 1208\n",
      "Printing out the 20 most often occuring ..\n",
      "[('building', 97193), ('addr:street', 55440), ('addr:housenumber', 54966), ('addr:city', 52773), ('addr:postcode', 49757), ('addr:country', 49456), ('highway', 37212), ('name', 20307), ('source', 20019), ('amenity', 7134), ('lit', 6700), ('maxspeed', 5209), ('foot', 4795), ('bicycle', 4658), ('access', 4293), ('service', 3942), ('ref', 3729), ('surface', 3601), ('barrier', 3418), ('oneway', 3343)]\n",
      "__________________________________________________ \n",
      "\n",
      "RESULT FOR auditPos: (i.e.: all lat and lon out of range) \n",
      "\n",
      "Number of wrong latitude positions: 5438\n",
      "Number of wrong longitude positions: 7032\n",
      "Printing out first 20 latitude values ..\n",
      "[50.7798168, 50.6445447, 50.6437195, 50.6418831, 50.6384231, 50.6366305, 50.6347091, 50.6331468, 50.6312489, 50.6302393, 50.6293082, 50.7745478, 50.7846916, 50.7832439, 50.7820479, 50.7829087, 50.7816577, 50.7810368, 50.7796285, 50.7787235]\n",
      "Printing out first 20 longitude values ..\n",
      "[7.0207407, 7.0194337, 7.0189245, 7.0186928, 7.0189586, 7.019269, 7.019805, 7.0202863, 7.0209736, 7.0205883, 7.0203549, 7.0200036, 7.0198694, 7.0196897, 7.0195328, 7.0196508, 7.0198828, 7.0203434, 7.0207255, 6.977695]\n",
      "\n",
      "--- Execution time: 3.825 min ---\n"
     ]
    }
   ],
   "source": [
    "############################################################\n",
    "# Comment/Uncomment the following two lines to choose \n",
    "# whether you wants to run the code with Raw or Sample File:\n",
    "file = rawfile\n",
    "#file = samplefile\n",
    "############################################################\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "result_auditStrasse = []\n",
    "types_of_k_tags = {}\n",
    "WrongPos = {'lat':[],'lon':[]}\n",
    "\n",
    "def auditStrasse(element):\n",
    "    if element.get(\"v\"): #ensure that tag is not None\n",
    "        \n",
    "        if \"strasse\" in elem.get(\"v\") or \"Strasse\" in elem.get(\"v\"):\n",
    "            \n",
    "            if elem.get(\"v\").startswith(\"http\"): #check if URL\n",
    "                pass\n",
    "            else:\n",
    "                return elem.get(\"v\")\n",
    "                     \n",
    "def auditK(element):\n",
    "    if element.tag == \"tag\":\n",
    "        k = element.get(\"k\")\n",
    "        if k not in types_of_k_tags:\n",
    "            types_of_k_tags[k]=1\n",
    "        else:\n",
    "            types_of_k_tags[k]+=1\n",
    "            \n",
    "def auditPos(element):\n",
    "    pos=[None,None]\n",
    "    if element.tag == \"node\" or element.tag == \"way\" :      \n",
    "        node_dict = element.attrib\n",
    "        \n",
    "        if node_dict.has_key('lat'):\n",
    "            lat = float(node_dict['lat'])\n",
    "            if lat < 50.6460 or lat > 50.7738: #check latitudes out of range\n",
    "                pos[0]=lat                        \n",
    "            \n",
    "        if node_dict.has_key('lon'):\n",
    "            lon = float(node_dict['lon'])\n",
    "            if lon < 7.0210 or lon > 7.2180: #check longitudes out of range\n",
    "                pos[1]=lon\n",
    "    \n",
    "    return pos              \n",
    "\n",
    "with open(file) as f:\n",
    "    for event, elem in ET.iterparse(f):\n",
    "    #for event, elem in islice(ET.iterparse(f),0,100000):    \n",
    "        if auditStrasse(elem):\n",
    "            result_auditStrasse.append(auditStrasse(elem))\n",
    "        \n",
    "        auditK(elem)    \n",
    "\n",
    "        if auditPos(elem)[0] != None:          \n",
    "            WrongPos['lat'].append(auditPos(elem)[0])\n",
    "        if auditPos(elem)[1] != None:          \n",
    "            WrongPos['lon'].append(auditPos(elem)[1])\n",
    "\n",
    "# Convert dict in ordered list:\n",
    "# Ref: http://stackoverflow.com/a/7971655\n",
    "ordered_k = sorted(types_of_k_tags.items(), reverse=True, key=lambda x:x[1])\n",
    "    \n",
    "print \"RESULT FOR auditStrasse:\",'\\n'\n",
    "print (\"Number of words containing 'Strasse' instead of 'Straße': %d\" % (len(result_auditStrasse)) )\n",
    "print \"__________________________________________________\",'\\n'\n",
    "\n",
    "print \"RESULT FOR auditK: (i.e.: list of all k-tags)\",'\\n'  \n",
    "print (\"Number of k-tags: %d\" % (len(ordered_k)) )\n",
    "print \"Printing out the 20 most often occuring ..\"\n",
    "print ordered_k[0:20]\n",
    "\n",
    "print \"__________________________________________________\",'\\n'\n",
    "print \"RESULT FOR auditPos: (i.e.: all lat and lon out of range)\",'\\n'  \n",
    "print (\"Number of wrong latitude positions: %d\" % (len(WrongPos['lat'])) )\n",
    "print (\"Number of wrong longitude positions: %d\" % (len(WrongPos['lon'])) )\n",
    "print \"Printing out first 20 latitude values ..\"\n",
    "print WrongPos['lat'][0:20]\n",
    "print \"Printing out first 20 longitude values ..\"\n",
    "print WrongPos['lon'][0:20]\n",
    "\n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Checking for abbreviations of \"Strasse\":"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of street abbreviations: 170\n",
      "Printing out first 10 ..\n",
      "['v=\"Simrockstr.', 'v=\"Clemens-August-Str.', 'v=\"Hausdorffstr.', 'v=\"R\\xc3\\xb6ckumstr.', 'v=\"Prinz-Albert-Str.', 'v=\"R\\xc3\\xb6merstr.', 'v=\"Vorgebirgsstr.', 'Str.', 'v=\"K\\xc3\\xb6lnstr.', 'v=\"Verweyenstr.']\n",
      "\n",
      "--- Execution time: 0.181 min ---\n"
     ]
    }
   ],
   "source": [
    "############################################################\n",
    "# Comment/Uncomment the following two lines to choose \n",
    "# whether you wants to run the code with Raw or Sample File:\n",
    "file = rawfile\n",
    "#file = samplefile\n",
    "############################################################\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "results = []\n",
    "\n",
    "with open(file) as f:\n",
    "    for lines in f:\n",
    "        for word in lines.split():\n",
    "            if word.endswith((\"Str.\", \"Str\", \"str.\", \"str\")):\n",
    "                results.append(word)\n",
    "\n",
    "print (\"Number of street abbreviations: %d\" %len(results) )\n",
    "print \"Printing out first 10 ..\"\n",
    "print results[0:10]\n",
    "\n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='CleaningData'></a>  \n",
    "### 3.2 Cleaning the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='ReplaceUmlaute'></a> \n",
    "#### 3.2.1 Replace German Umlaute"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Execution time: 0.926 min ---\n"
     ]
    }
   ],
   "source": [
    "############################################################\n",
    "# Comment/Uncomment the following two lines to choose \n",
    "# whether you wants to run the code with Raw or Sample File:\n",
    "file = rawfile\n",
    "#file = samplefile\n",
    "############################################################\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "umlaute = {'ä':\"ae\", 'ö':\"oe\", 'ü':\"ue\", 'Ä':\"Ae\", 'Ö':\"Oe\", 'Ü':\"Ue\", 'ß':\"ss\"}\n",
    "\n",
    "def replaceUmlaute(line):    \n",
    "    for i in umlaute:\n",
    "        line = line.replace(i,umlaute[i])\n",
    "    return line\n",
    "\n",
    "with open(file) as infile:\n",
    "    with open(outputfile,\"w\") as outfile:\n",
    "        for line in infile:\n",
    "            line_changed = replaceUmlaute(line)\n",
    "            outfile.write(line_changed)\n",
    "            \n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='ReplaceAbbrStr'></a> \n",
    "#### 3.2.2 Replace Abbreviations of Street"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Execution time: 0.633 min ---\n"
     ]
    }
   ],
   "source": [
    "############################################################\n",
    "# Comment/Uncomment the following two lines to choose \n",
    "# whether you wants to run the code with Raw or Sample File:\n",
    "file = rawfile\n",
    "#file = samplefile\n",
    "############################################################\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "abbr = {'Str.':\"Strasse\", 'St':\"Strasse\", 'str.':\"strasse\", 'st':\"strasse\"}\n",
    "\n",
    "def replaceAbbr(line):\n",
    "    for word in line.split():\n",
    "        if word.endswith((\"Str.\", \"Str\", \"str.\", \"str\")):\n",
    "            for i in abbr:\n",
    "                new_word = word.replace(i, abbr[i])\n",
    "                line = line.replace(word, new_word)\n",
    "    return line\n",
    "\n",
    "with open(file) as infile:\n",
    "    with open(outputfile,\"w\") as outfile:\n",
    "        for line in infile:\n",
    "            line_changed = replaceAbbr(line)\n",
    "            outfile.write(line_changed)         \n",
    "            \n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='FinalClean'></a> \n",
    "#### 3.2.3 Final Cleaning and Building of JSON-File"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "problemchars = re.compile(r'[=\\+/&<>;\\'\"\\?%#$@\\,\\. \\t\\r\\n]')\n",
    "umlautchars = re.compile(r'[äöü]')\n",
    "\n",
    "def shape_element(element):\n",
    "    node = {}\n",
    "    if element.tag == \"node\" or element.tag == \"way\" :\n",
    "        # A: Atrributes of node\n",
    "        #####################################################################################\n",
    "        node_dict = element.attrib #the whole node as an dict as a starting point for cleaning\n",
    "        \n",
    "        ##############################\n",
    "        # UPDATE POSITION-INFORMATION:\n",
    "        if ('lat' and 'lon') in node_dict:\n",
    "            node_dict['pos'] = [ float(node_dict['lat']), float(node_dict['lon'])] #create new key\n",
    "            del node_dict['lat'] #delete old entries\n",
    "            del node_dict['lon'] #     \"        \n",
    "        \n",
    "        ##############################\n",
    "        # Build entry 'created':\n",
    "        node_dict['created'] = {\n",
    "                                \"version\": node_dict['version'],\n",
    "                                \"changeset\": node_dict['changeset'],\n",
    "                                \"timestamp\": node_dict['timestamp'],\n",
    "                                \"user\": node_dict['user'],\n",
    "                                \"uid\": node_dict['uid']\n",
    "                                }\n",
    "        del node_dict['version']\n",
    "        del node_dict['changeset']\n",
    "        del node_dict['timestamp']\n",
    "        del node_dict['user']\n",
    "        del node_dict['uid']                 \n",
    "        \n",
    "        ##############################\n",
    "        # Add 'type'-key:\n",
    "        node_dict['type'] = element.tag\n",
    "                        \n",
    "        # B: Handle attribute k in <tag>\n",
    "        #####################################################################################\n",
    "        \n",
    "        # B1: Add address-key:\n",
    "        address_dict={}\n",
    "      \n",
    "        for i in element.iter('tag'):\n",
    "            k = i.attrib['k']\n",
    "            v = i.attrib['v']\n",
    "            \n",
    "            if problemchars.search(k):\n",
    "                pass\n",
    " \n",
    "            else:\n",
    "                #check for second colon:\n",
    "                if k.count(':') >1:\n",
    "                    pass\n",
    "                else:\n",
    "                    # check for address:\n",
    "                    if k.startswith(\"addr:\"):\n",
    "                        address_dict[k[5:]] = v\n",
    "                    \n",
    "        # B2: Add all other k:\n",
    "                    else:\n",
    "                        node_dict[k]=v\n",
    "\n",
    "        if address_dict:\n",
    "            node_dict['address'] = address_dict\n",
    "        \n",
    "        nd_list = []\n",
    "        for i in element.iter('nd'):   \n",
    "            nd_list.append(i.attrib['ref'])\n",
    "        \n",
    "        if nd_list:\n",
    "            node_dict['node_refs'] = nd_list\n",
    "                \n",
    "        node = node_dict\n",
    "        \n",
    "        return node\n",
    "    \n",
    "    else:\n",
    "        return None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Execution time: 7.531 min ---\n"
     ]
    }
   ],
   "source": [
    "# Write the json-file while cleaning the data elment by element (-> ...)\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "\n",
    "def process_map(file_in, pretty = False):\n",
    "    data = []\n",
    "    with codecs.open(path_to_data, \"w\") as fo:\n",
    "        for _, element in ET.iterparse(file_in): \n",
    "            el = shape_element(element)\n",
    "            if el:\n",
    "                data.append(el)\n",
    "                if pretty:\n",
    "                    fo.write(json.dumps(el, indent=2)+\"\\n\")\n",
    "                else:\n",
    "                    fo.write(json.dumps(el) + \"\\n\")\n",
    "    return data\n",
    "\n",
    "data = process_map(outputfile)\n",
    "\n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='ImportingData'></a>\n",
    "## 4 Importing the Data into MongoDB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Importing the data into MongoDB is straight forward. As recommended in the course, I did this via the terminal. Simply open a **new** terminal window *(Note: not in the Mongo shell)* and type:\n",
    "\n",
    "`mongoimport -db dbname -c collectionname --file filename.json`\n",
    "\n",
    "In my case I imported the data into collection _Bonn_ of the database _udacity_: \n",
    "\n",
    "`mongoimport -d udacity -c Bonn --file /Users/dirkkalmbach/Programming/Nanodegree/ud032/ud032_finalProject/data/wrangled_OSM.json`\n",
    "\n",
    "See also the following two screenshots:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"Terminal_oben.png\">\n",
    "<img src=\"Terminal_unten.png\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Checking if collection _Bonn_ was inserted in database _udacity_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false,
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[u'twitter',\n",
       " u'system.indexes',\n",
       " u'twitter_sample',\n",
       " u'cities',\n",
       " u'Bonn',\n",
       " u'Bonn_sample']"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "client = MongoClient() #connet to MongoDB\n",
    "db = client.udacity #choose database udacity\n",
    "db.collection_names() #show collections in database udacity"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Basic Statistics of the Collection "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{u'count': 855049, u'ns': u'udacity.Bonn', u'ok': 1.0, u'lastExtentSize': 92585984, u'avgObjSize': 299, u'totalIndexSize': 27757520, u'systemFlags': 1, u'userFlags': 1, u'numExtents': 14, u'nindexes': 1, u'storageSize': 335900672, u'indexSizes': {u'_id_': 27757520}, u'paddingFactor': 1.0, u'size': 256466032}\n"
     ]
    }
   ],
   "source": [
    "stats = db.command(\"collstats\", \"Bonn\")\n",
    "print stats"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_**Hint:** If these values (esp. the documents count) differ from the values in terminal, you might had already a collection with the same name in MongoDB and added the new collection (instead of replacing). In this case simply run `db.Bonn.drop()` either from Python or from the terminal._"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Analyzing'></a>\n",
    "## 5 Analyzing the Data with Pymongo"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Overview'></a>\n",
    "### 5.1 Overview of the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Print out first document"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{u'_id': ObjectId('556c54fc2c799ca0e7a41515'),\n",
      " u'created': {u'changeset': u'27654675',\n",
      "              u'timestamp': u'2014-12-23T16:46:12Z',\n",
      "              u'uid': u'39774',\n",
      "              u'user': u'MKnight',\n",
      "              u'version': u'8'},\n",
      " u'id': u'2702011',\n",
      " u'pos': [50.7648601, 7.1292655],\n",
      " u'type': u'node'}\n"
     ]
    }
   ],
   "source": [
    "pprint.pprint( db.Bonn.find_one() )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Size of the Collection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Collection Size: 244 MB\n",
      "Average Object Size: 299 bytes\n"
     ]
    }
   ],
   "source": [
    "print(\"Collection Size: %d MB\" %float(stats['size']/1024**2))\n",
    "print(\"Average Object Size: %d bytes\" %float(stats['avgObjSize']))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Number of Nodes and Ways"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Number of Nodes: 717138\n",
      "Number of Ways: 137777\n"
     ]
    }
   ],
   "source": [
    "nodes = db.Bonn.find({\"type\":\"node\"}).count()\n",
    "ways = db.Bonn.find({\"type\":\"way\"}).count()\n",
    "print (\"Number of Nodes: %d\" %int(nodes))\n",
    "print (\"Number of Ways: %d\" %int(ways))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Top 3 contributing user"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{u'ok': 1.0,\n",
      " u'result': [{u'_id': u'ARWIE', u'count': 110774},\n",
      "             {u'_id': u'dschuwa', u'count': 110724},\n",
      "             {u'_id': u'dalchimsky', u'count': 96642}]}\n"
     ]
    }
   ],
   "source": [
    "pprint.pprint(\n",
    "    db.Bonn.aggregate([\n",
    "        {\"$group\":{\"_id\":\"$created.user\", \"count\":{\"$sum\":1}}},\n",
    "        {\"$sort\":{\"count\":-1}},\n",
    "        {\"$limit\":3}\n",
    "    ]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Top 10 tourism attractions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We start with investigating the tag _tourism_.[[3]](#3) The following code prints out the 10 most often appearing values of the tag _tourism_:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{u'ok': 1.0,\n",
       " u'result': [{u'_id': u'information', u'count': 185},\n",
       "  {u'_id': u'hotel', u'count': 109},\n",
       "  {u'_id': u'attraction', u'count': 69},\n",
       "  {u'_id': u'viewpoint', u'count': 46},\n",
       "  {u'_id': u'museum', u'count': 35},\n",
       "  {u'_id': u'picnic_site', u'count': 25},\n",
       "  {u'_id': u'artwork', u'count': 22},\n",
       "  {u'_id': u'guest_house', u'count': 10},\n",
       "  {u'_id': u'hostel', u'count': 7},\n",
       "  {u'_id': u'zoo', u'count': 3}]}"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "db.Bonn.aggregate([\n",
    "        {\"$match\":{\"tourism\":{\"$exists\":1}}},\n",
    "        {\"$group\":\n",
    "         {\"_id\":\"$tourism\",\"count\":{\"$sum\":1}}}, \n",
    "        {\"$sort\":{\"count\":-1}}, \n",
    "        {\"$limit\":10}\n",
    "    ])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Among these values we are particulary interested in\n",
    "- attractions, and\n",
    "- museums.\n",
    "\n",
    "Let's start with printing out all kind attractions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[{u'name of attraction': u'Busbahnhof Bonn'},\n",
      " {u'name of attraction': u'Deutsche Welle'},\n",
      " {u'name of attraction': u'Beethovenstatue'},\n",
      " {u'name of attraction': u'Kurf\\xfcrst Maximilian Friedrich'},\n",
      " {u'name of attraction': u'Konrad Adenauer Denkmal'},\n",
      " {u'name of attraction': u'Hermann-L\\xf6ns Denkmal'},\n",
      " {u'name of attraction': u'St. Adelheid-Brunnen'},\n",
      " {u'name of attraction': u'R\\xf6mischer Sarkophag'},\n",
      " {u'name of attraction': u'R\\xf6merkran'},\n",
      " {u'name of attraction': u'Beethoven-Skulptur \"Beethon\"'}]\n",
      "Number of attractions: 67\n"
     ]
    }
   ],
   "source": [
    "attractions = db.Bonn.aggregate([\n",
    "        {\"$match\":\n",
    "         {\"tourism\":{\"$exists\":1}, \"tourism\":\"attraction\"}},\n",
    "        {\"$match\":\n",
    "         {\"name\":{\"$exists\":1}}},\n",
    "        {\"$project\":{\"name of attraction\":\"$name\", \"_id\":0}}\n",
    "    ])\n",
    "\n",
    "pprint.pprint (attractions[\"result\"][0:10])\n",
    "print \"Number of attractions:\", len(attractions[\"result\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And the same for museums:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[{u'name of museum': u'Deutsches Museum Bonn'},\n",
      " {u'name of museum': u'StadtMuseum Bonn'},\n",
      " {u'name of museum': u'Br\\xfcckenhofmuseum'},\n",
      " {u'name of museum': u'Radiomuseum und Galerie'},\n",
      " {u'name of museum': u'Siebengebirgsmuseum'},\n",
      " {u'name of museum': u'Schloss Deichmannsaue'},\n",
      " {u'name of museum': u'Arithmeum'},\n",
      " {u'name of museum': u'Goldfu\\xdf-Museum'},\n",
      " {u'name of museum': u'Mineralogisches Museum'},\n",
      " {u'name of museum': u'Stiftung Bundeskanzler-Adenauer-Haus'}]\n",
      "Number of museums: 35\n"
     ]
    }
   ],
   "source": [
    "museums = db.Bonn.aggregate([\n",
    "        {\"$match\":\n",
    "         {\"tourism\":{\"$exists\":1}, \"tourism\":\"museum\"}},\n",
    "        {\"$match\":\n",
    "         {\"name\":{\"$exists\":1}}},\n",
    "        {\"$project\":{\"name of museum\":\"$name\", \"_id\":0}}\n",
    "    ])\n",
    "\n",
    "pprint.pprint (museums[\"result\"][0:10])\n",
    "print \"Number of museums:\", len(museums[\"result\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Ideas'></a>\n",
    "### 5.2 Other Ideas about the Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Map'></a>\n",
    "#### 5.2.1 Create Map of Distances"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "#Create List of Points which I want to combine visually later \n",
    "listOfPos = []\n",
    "listOfLon = []\n",
    "# Find Telephone-Boxes in Bonn:\n",
    "query=db.Bonn.find({\"amenity\":\"telephone\"})\n",
    "for entry in query:\n",
    "    listOfPos.append(entry['pos'])\n",
    "len(listOfPos)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As this list is too long for visual representation, the following code choose 10 entries randomly:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[50.6940849, 7.1776265],\n",
       " [50.72284, 7.0648133],\n",
       " [50.7335018, 7.0871448],\n",
       " [50.7339568, 7.0832515],\n",
       " [50.7278262, 7.1472209],\n",
       " [50.6854402, 7.1582493],\n",
       " [50.713927, 7.0711076],\n",
       " [50.6837422, 7.1538766],\n",
       " [50.7019436, 7.1175706],\n",
       " [50.7194573, 7.1163951]]"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#random.seed(5)\n",
    "listOfPos = random.sample(listOfPos, 10)\n",
    "listOfPos"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following code seperates the long- and lat-values from the list:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "lat=[]\n",
    "lon=[]\n",
    "for i in range(0,len(listOfPos)):\n",
    "    lat.append( listOfPos[i][0] )\n",
    "for i in range(0,len(listOfPos)):\n",
    "    lon.append( listOfPos[i][1] )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we need a starting point, i.e.: a coordinate inside the city boundary from which we begin our _walk_. I decided to choose the coordinates of the __main station__,[[4]](#4) as this is one of the most central places in Bonn and for many visitors a typical starting point."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "start=[50.731944,7.096944] #Position of Bonn Main Station"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We no can calculate the distances of all points to each other using euclidian distance measurement. Afterwards, we sort the lon-lat-coordinates in a list in order of drawing, i.e.: the first entry represents our starting point, the second entry represents the point nearest to the starting point, the third entry represents the nearest point to the last point, etc."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[50.7335018, 7.0871448], [50.7339568, 7.0832515], [50.7194573, 7.1163951], [50.713927, 7.0711076], [50.72284, 7.0648133], [50.7019436, 7.1175706], [50.7278262, 7.1472209], [50.6837422, 7.1538766], [50.6854402, 7.1582493], [50.6940849, 7.1776265]]\n"
     ]
    }
   ],
   "source": [
    "points = listOfPos\n",
    "\n",
    "orderedPoints = []\n",
    "\n",
    "def findNearPoint(startPoint,listOfPoints):\n",
    "    dictOfDist={}\n",
    "    order=0\n",
    "    for i in listOfPoints:\n",
    "        d= math.sqrt((startPoint[0]-i[0])**2 + (startPoint[1]-i[1])**2)\n",
    "        dictOfDist[order]=d #add distance as value in dict\n",
    "        order+=1\n",
    "    index_of_d_min = min(dictOfDist, key=dictOfDist.get)\n",
    "    return index_of_d_min\n",
    "        \n",
    "for i in range(1,len(points)+1):       \n",
    "    x = findNearPoint(start,points)\n",
    "    orderedPoints.append( points[x] )\n",
    "    #listofPos.remove(listOfPos[x])\n",
    "    del(points[x])\n",
    "    \n",
    "print orderedPoints"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, we need to add our starting point (in our case the coordinates of the main station) to our list at the beginning:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "orderedPoints.insert(0,start)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can plot our graph. The blue point represents the main station, the red points represents the randomly selected telephone boxes, and the arrows shows the shortest way between the telephone boxes, starting from main station:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n3v4/V1XSYwZEHUQAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<matplotlib.figure.Figure at 0x288aaecd0>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#Subplot of 'red' points:          \n",
    "plt.subplot(111)    \n",
    "plt.plot(lat, lon, 'ro')\n",
    "\n",
    "#Subplot of 'blue' starting point:\n",
    "plt.subplot(111)    \n",
    "plt.plot(start[0], start[1], 'ro', color=\"b\", markersize =20)\n",
    "\n",
    "plt.title('Which Telephone Box is the next nearest?')\n",
    "plt.ylabel('latitude')\n",
    "plt.xlabel('longitude')\n",
    "\n",
    "#Draw arrows:\n",
    "for i in range (0, len(orderedPoints)-1):\n",
    "    plt.subplot(111)\n",
    "    plt.annotate(\n",
    "        '', xy=(orderedPoints[i]), #start\n",
    "        xytext=(orderedPoints[i+1]), #end\n",
    "        arrowprops={'arrowstyle': '<-'})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Distance'></a>\n",
    "#### 5.2.2 Calculate Distances"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_The following code calculates the distance in kilometer and miles between touristic point of interests, i.e.: between museums and/or tourism attractions:_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Distance between Arithmeum and Siebengebirgsmuseum: 10.41 km (6.46 miles)\n"
     ]
    }
   ],
   "source": [
    "# calculating distance between two sightseeing points:\n",
    "# SightseeingPoints are either museums or attractions\n",
    "\n",
    "# pick a museum or an attraction from the above lists and insert it:\n",
    "sp1 = [\"Arithmeum\"] # <- change this name\n",
    "sp2 = [\"Siebengebirgsmuseum\"] # <- change this name\n",
    "\n",
    "#ways = db.Bonn.find({\"type\":\"way\"}).count()\n",
    "#print (\"Number of Nodes: %d\" %int(nodes))\n",
    "\n",
    "# Pick GeoInformation for both sightseeing points from db.Bonn:\n",
    "for entry in db.Bonn.find({\"name\":sp1[0]}):\n",
    "    sp1.append( entry['pos'] )\n",
    "for entry in db.Bonn.find({\"name\":sp2[0]}):\n",
    "    sp2.append( entry['pos'] )\n",
    "    \n",
    "# Calculate distance:\n",
    "d = math.sqrt( (sp1[1][0]-sp2[1][0])**2 + (sp1[1][1]-sp2[1][1])**2 )\n",
    "\n",
    "print \"Distance between {0} and {1}: {2} km ({3} miles)\".format(sp1[0],sp2[0],round(d*100,2),round(d*100*0.621,2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='References'></a>\n",
    "## References"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. Link to open street map export api _(Warning: Click on the link downloads the osm-data (181.7 MB) instantly)_, [URL](http://overpass-api.de/api/map?bbox=7.0210,50.6460,7.2180,50.7738) <a id='1'></a>\n",
    "\n",
    "2. Code to create a smaller sample of the osm file, [URL](https://www.udacity.com/course/viewer/#!/c-nd002/l-3168208620/m-3189488621) <a id='2'></a>\n",
    "\n",
    "3. Link to open street map wiki page, where all types of keys are explained, [URL](http://taginfo.openstreetmap.org/keys) <a id='3'></a>\n",
    "\n",
    "4. Link to the wikipedia page of _Bonn Hauptbahnhof_ (engl. Bonn Central Station), [URL](http://en.wikipedia.org/wiki/Bonn_Hauptbahnhof) <a id='4'></a>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Appendix'></a>\n",
    "## Appendix"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='ImportModules'></a>\n",
    "### A.1 Import Modules"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import xml.etree.ElementTree as ET\n",
    "import xml.etree.cElementTree as cET\n",
    "from collections import defaultdict\n",
    "import pprint\n",
    "import re\n",
    "import os\n",
    "import math\n",
    "import codecs\n",
    "import json\n",
    "import random\n",
    "from pymongo import MongoClient\n",
    "from itertools import islice\n",
    "import timeit\n",
    "import time\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='CreatingSampleData'></a>\n",
    "### A.2 Creating a Sample Data File"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Execution time: 2.146 min ---\n"
     ]
    }
   ],
   "source": [
    "#!/usr/bin/env python\n",
    "# -*- coding: utf-8 -*-\n",
    "\n",
    "OSM_FILE = rawfile \n",
    "samplefile = \"sample.osm\"\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "\n",
    "def get_element(osm_file, tags=('node', 'way', 'relation')):\n",
    "    \"\"\"Yield element if it is the right type of tag\n",
    "\n",
    "    Reference:\n",
    "    http://stackoverflow.com/questions/3095434/inserting-newlines-in-xml-file-generated-via-xml-etree-elementtree-in-python\n",
    "    \"\"\"\n",
    "    context = ET.iterparse(osm_file, events=('start', 'end'))\n",
    "    _, root = next(context)\n",
    "    for event, elem in context:\n",
    "        if event == 'end' and elem.tag in tags:\n",
    "            yield elem\n",
    "            root.clear()\n",
    "\n",
    "\n",
    "with open(samplefile, 'wb') as output:\n",
    "    output.write('<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n')\n",
    "    output.write('<osm>\\n  ')\n",
    "\n",
    "    # Write every 20th top level element\n",
    "    for i, element in enumerate(get_element(OSM_FILE)):\n",
    "        if i % 20 == 0:\n",
    "            output.write(ET.tostring(element, encoding='utf-8'))\n",
    "\n",
    "    output.write('</osm>')\n",
    "\n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='CheckUmlaute'></a>\n",
    "### A.3 Check for Umlaute"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "German Umlaute can be written in their substitute form (e.g. ä -> ae). The following code finds all occurences of ae, oe (=ö), ue (=ü) which are not part of urls or email-adresses:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "11055\n",
      "['Bonn-Beuel', 'Bonn-Rheinaue', 'Bonn-Auerberg', 'Bonn-Auerberg', 'Bonn-Rheinaue']\n",
      "\n",
      "--- Execution time: 3.798 min ---\n"
     ]
    }
   ],
   "source": [
    "# Check for all Umlaute which are written in longform (i.e.: words containing 'ae', 'ue', ..)\n",
    "\n",
    "############################################################\n",
    "# Comment/Uncomment the following two lines to choose \n",
    "# whether you wants to run the code with Raw or Sample File:\n",
    "file = rawfile\n",
    "#file = samplefile\n",
    "############################################################\n",
    "\n",
    "start_time = time.time() #start timer\n",
    "\n",
    "def findUmlaute(data):\n",
    "    umlaute_longform = ['ae','ue','oe','Ae','Ue','Oe']\n",
    "    result = []\n",
    "    with open(data) as f:\n",
    "        for event, elem in ET.iterparse(f):\n",
    "        #for event,elem in islice(ET.iterparse(f),1,100):\n",
    "            if elem.tag == \"tag\":\n",
    "                v = elem.get(\"v\")\n",
    "                for i in umlaute_longform:               \n",
    "                    if i in v and i not in result: #check if umlaut in tag\n",
    "                        if not v.startswith(\"http\"): #skip urls\n",
    "                            if \"@\" not in v: #skip emails\n",
    "                                result.append(v)  \n",
    "    return result\n",
    "\n",
    "listOfUmlaute = findUmlaute(file)\n",
    "print len( listOfUmlaute )\n",
    "print listOfUmlaute[0:5]\n",
    "\n",
    "#CALCULATE & PRINTOUT EXECUTION TIME\n",
    "execution_time = ( round((time.time() - start_time)/60,3) )\n",
    "print '\\n',(\"--- Execution time: %s min ---\" %execution_time)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_**Interpretation:** 11055 (in the Raw File) are too many results for manually checking!_"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<a id='Printouts'></a>\n",
    "### A.4 Printouts of data-files"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following code prints out the first 10 lines for every data file to help to evaluate the content of the files."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Printout for raw data (`rawfile` or `samplefile`)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n",
      "\n",
      "<osm>\n",
      "\n",
      "  <node changeset=\"27654675\" id=\"2702011\" lat=\"50.7648601\" lon=\"7.1292655\" timestamp=\"2014-12-23T16:46:12Z\" uid=\"39774\" user=\"MKnight\" version=\"8\" />\n",
      "\n",
      "  <node changeset=\"17711290\" id=\"11131978\" lat=\"50.6816238\" lon=\"7.1418429\" timestamp=\"2013-09-06T22:48:05Z\" uid=\"666059\" user=\"RobKehl\" version=\"9\" />\n",
      "\n",
      "  <node changeset=\"12132579\" id=\"11132149\" lat=\"50.6954366\" lon=\"7.1615631\" timestamp=\"2012-07-06T17:05:48Z\" uid=\"55687\" user=\"dschuwa\" version=\"10\">\n",
      "\n",
      "    <tag k=\"highway\" v=\"traffic_signals\" />\n",
      "\n",
      "  </node>\n",
      "\n",
      "  <node changeset=\"19547140\" id=\"11132452\" lat=\"50.7219667\" lon=\"7.1483583\" timestamp=\"2013-12-20T10:08:02Z\" uid=\"184969\" user=\"EvanE\" version=\"2\" />\n",
      "\n",
      "  <node changeset=\"22951609\" id=\"11132666\" lat=\"50.7242234\" lon=\"7.1647651\" timestamp=\"2014-06-15T20:13:14Z\" uid=\"2675\" user=\"Eckhart Wörner\" version=\"13\" />\n",
      "\n",
      "  <node changeset=\"27654675\" id=\"21185800\" lat=\"50.7693388\" lon=\"7.1426009\" timestamp=\"2014-12-23T16:46:11Z\" uid=\"39774\" user=\"MKnight\" version=\"6\" />\n",
      "\n"
     ]
    }
   ],
   "source": [
    "with open(samplefile) as f:\n",
    "    for i in islice(f,0,10):\n",
    "        print i"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Printout for wrangled data (`data`)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'created': {'changeset': '27654675',\n",
      "             'timestamp': '2014-12-23T16:46:12Z',\n",
      "             'uid': '39774',\n",
      "             'user': 'MKnight',\n",
      "             'version': '8'},\n",
      " 'id': '2702011',\n",
      " 'pos': [50.7648601, 7.1292655],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '9696743',\n",
      "             'timestamp': '2011-10-30T18:29:52Z',\n",
      "             'uid': '116044',\n",
      "             'user': 'berndw',\n",
      "             'version': '11'},\n",
      " 'id': '2702022',\n",
      " 'pos': [50.7654175, 7.137618],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '27362963',\n",
      "             'timestamp': '2014-12-09T18:47:47Z',\n",
      "             'uid': '1751908',\n",
      "             'user': 'Blues Brothers',\n",
      "             'version': '5'},\n",
      " 'id': '2702027',\n",
      " 'pos': [50.7704923, 7.1432462],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '18442764',\n",
      "             'timestamp': '2013-10-19T22:50:43Z',\n",
      "             'uid': '45243',\n",
      "             'user': 'odna',\n",
      "             'version': '10'},\n",
      " 'id': '2703359',\n",
      " 'pos': [50.7548501, 7.096464],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '12767394',\n",
      "             'timestamp': '2012-08-17T21:13:31Z',\n",
      "             'uid': '49785',\n",
      "             'user': 'mike67',\n",
      "             'version': '14'},\n",
      " 'id': '2703367',\n",
      " 'pos': [50.7533923, 7.0942377],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '12767394',\n",
      "             'timestamp': '2012-08-17T21:13:31Z',\n",
      "             'uid': '49785',\n",
      "             'user': 'mike67',\n",
      "             'version': '4'},\n",
      " 'id': '2703368',\n",
      " 'pos': [50.7530709, 7.0935736],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '12392812',\n",
      "             'timestamp': '2012-07-20T21:25:45Z',\n",
      "             'uid': '55687',\n",
      "             'user': 'dschuwa',\n",
      "             'version': '3'},\n",
      " 'id': '2703372',\n",
      " 'pos': [50.7515149, 7.0952592],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '12392812',\n",
      "             'timestamp': '2012-07-20T21:25:45Z',\n",
      "             'uid': '55687',\n",
      "             'user': 'dschuwa',\n",
      "             'version': '9'},\n",
      " 'id': '2703373',\n",
      " 'pos': [50.7517534, 7.0959917],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '7927491',\n",
      "             'timestamp': '2011-04-21T17:37:47Z',\n",
      "             'uid': '49785',\n",
      "             'user': 'mike67',\n",
      "             'version': '10'},\n",
      " 'id': '2703378',\n",
      " 'pos': [50.7554282, 7.0910601],\n",
      " 'type': 'node'}\n",
      "{'created': {'changeset': '17544383',\n",
      "             'timestamp': '2013-08-27T20:42:15Z',\n",
      "             'uid': '133419',\n",
      "             'user': 'dachefte',\n",
      "             'version': '7'},\n",
      " 'id': '2703428',\n",
      " 'pos': [50.7587324, 7.103913],\n",
      " 'type': 'node'}\n"
     ]
    }
   ],
   "source": [
    "for i in islice(data,0,10):\n",
    "    pprint.pprint(i)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
